#!/usr/bin/env node

var Crypto = require('crypto');
var Exec = require('child_process').exec;
var Fs = require('fs');
var Path = require('path');


// Given a path, determine if the path is a directory
//
// Returns true/false
exports.isDir = function (path) {

    try {
        var stat = Fs.statSync(path);
        return stat.isDirectory();
    }
    catch (e) {
        return false;
    }
};


// Create a copy of process.env, with the PATH environment variable
// (case insensitive) modified to include the given project's
// node_modules/.bin directory.
//
// Returns an object suitable for child_process.exec
exports.getEnv = function (projectRoot) {

    // Disabling coverage on this line since we'll never be running tests
    // in a way such that process.platform is both 'win32' and not 'win32'
    /*$lab:coverage:off$*/
    var pathSep = process.platform === 'win32' ? ';' : ':';
    /*$lab:coverage:on$*/
    var env = {};

    for (var key in process.env) {
        if (key.toLowerCase() === 'path') {
            env[key] = Path.join(projectRoot, 'node_modules', '.bin') + pathSep + process.env[key];
        }
        else {
            env[key] = process.env[key];
        }
    }

    return env;
};


// Actually run the given script for the given project
exports.runCmd = function (projectRoot, script, done) {

    done = done || process.exit;
    var env = exports.getEnv(projectRoot);
    var gitRoot = exports.findGitRoot(projectRoot);
    var hash = Crypto.createHash('md5').update(Path.relative(gitRoot, projectRoot)).digest('hex');

    var hookPath = Path.join(gitRoot, '.git', 'hooks', 'pre-commit.d', hash, script);

    process.stdout.write('running ' + Path.basename(script) + ': ');

    Exec(hookPath, { cwd: projectRoot, env: env }, function (err, stdout, stderr) {
        if (err) {
            console.log('failed!');
            console.log(stdout);
            console.log(stderr);
            exports.exit(err.code, done);
        } else {
            console.log('ok.');
            exports.exit(0, done);
        }
    });
}


// This method shamelessly adapted from https://github.com/cowboy/node-exit
exports.exit = function (code, callback) {
    var streams = [process.stdout, process.stderr];
    var drainCount = 0;

    function tryToExit() {
        if (drainCount === streams.length) {
            callback(code);
        }
    }

    streams.forEach(function (stream) {
        if (stream.bufferSize === 0) {
            drainCount++;
        } else {
            stream.write('', 'utf-8', function () {
                drainCount++;
                tryToExit();
            });

            stream.write = function () {};
        }
    });

    tryToExit();
}


// Given a filename, copies the file to the git root's .git/hooks/pre-commit.d directory,
// also modifies the current project's package.json file to add the hook.
exports.registerHook = function (root, source) {

    var parentRoot = Path.dirname(module.parent.filename);

    if (!source) {
        source = root;
        root = parentRoot;
    }

    var gitRoot = exports.findGitRoot(root);
    var projectRoot = exports.findProjectRoot(root);
    var sourcePath = Path.resolve(parentRoot, source);

    var matcher = new RegExp('^' + parentRoot.replace('/', '\/') + '\/.*$');
    if (!matcher.test(sourcePath)) {
        return new Error('Source file may not be above project root: ' + projectRoot);
    }

    try {
        var precommitDir = Path.join(gitRoot, '.git', 'hooks', 'pre-commit.d');
        if (!exports.isDir(precommitDir)) {
            Fs.mkdirSync(precommitDir);
        }

        var hash = Crypto.createHash('md5').update(Path.relative(gitRoot, projectRoot)).digest('hex');
        if (!exports.isDir(Path.join(precommitDir, hash))) {
            Fs.mkdirSync(Path.join(precommitDir, hash));
        }

        var fileContent = Fs.readFileSync(sourcePath);
        Fs.writeFileSync(Path.join(precommitDir, hash, Path.basename(sourcePath)), fileContent);
        Fs.chmodSync(Path.join(precommitDir, hash, Path.basename(sourcePath)), '755');
    }
    catch (e) {
        return e;
    }
};


// Given a source file, and a destination path (relative to the project root),
// copy the source to the destination. If options.overwrite is false or not set,
// check to see if the file exists first and do not copy if it does. If true,
// always copy the file without checking
//
// Returns null if the file was copied, an Error object with explanation if it was not
exports.addFile = function (source, destination, options) {

    options = options || {};
    var root = Path.dirname(module.parent.filename);
    var projectRoot = exports.findProjectRoot(root);
    var sourcePath = Path.resolve(root, source);
    var destinationPath = Path.resolve(projectRoot, destination);

    var matcher = new RegExp('^' + projectRoot.replace('/', '\/') + '\/.*$');
    if (!matcher.test(destinationPath)) {
        return new Error('Destination must be within project root: ' + projectRoot);
    }

    if (!options.overwrite &&
        Fs.existsSync(destinationPath)) {

        return new Error('Destination ' + destinationPath + ' already exists.');
    }

    try {
        var fileContents = Fs.readFileSync(sourcePath);
        Fs.writeFileSync(destinationPath, fileContents);
    }
    catch (e) {
        return e;
    }
};


// Given a starting directory, find the root of a git repository.
// In this case, the root is defined as the first directory that contains
// a directory named ".git"
//
// Returns a string if found, otherwise undefined
exports.findGitRoot = function (start) {

    var root;

    if (exports.isDir(Path.join(start, '.git'))) {
        root = start;
    }
    else if (Path.dirname(start) !== start) {
        root = exports.findGitRoot(Path.dirname(start));
    }

    return root;
};


// Given a starting directory, find the root of the current project.
// The root of the project is defined as the topmost directory that is
// *not* contained within a directory named "node_modules" that also
// contains a file named "package.json"
//
// Returns a string
exports.findProjectRoot = function (start) {

    var position = start.indexOf('node_modules');
    var root = start.slice(0, position === -1 ? undefined : position - Path.sep.length);

    while (!Fs.existsSync(Path.join(root, 'package.json'))) {
        root = Path.dirname(root);
    }

    return root;
};


// Given a root path, find a list of projects.
// A project is defined as any directory within 4 levels of the starting
// directory that contains a file named "package.json"
//
// Returns an array
exports.findProjects = function (root, depth) {

    depth = depth || 0;
    ++depth;

    if (depth > 4 ||
        !exports.isDir(root) ||
        root.indexOf('node_modules') !== -1) {

        return [];
    }

    var dirs = Fs.readdirSync(root);
    var projects = [];

    for (var i = 0, il = dirs.length; i < il; ++i) {
        var dir = dirs[i];
        var path = Path.join(root, dir);

        if (Fs.existsSync(Path.join(path, 'package.json'))) {
            projects.push(path);
        }
        else {
            projects = projects.concat(exports.findProjects(path, depth));
        }
    }

    return projects;
};


// We weren't required, so perform our checks
if (!module.parent) {
    console.log('Running %s checks...', Path.basename(process.argv[1]));
}
