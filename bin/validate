#!/usr/bin/env node

var Exec = require('child_process').exec;
var Fs = require('fs');
var Path = require('path');
var Utils = require('../lib/utils');

var internals = {
    pathSep: process.platform === 'win32' ? ';' : ':'
};


// Create a copy of process.env, with the PATH environment variable
// (case insensitive) modified to include the given project's
// node_modules/.bin directory.
internals.getEnv = function (projectRoot) {

    var env = {};

    for (var key in process.env) {
        if (key.toLowerCase() === 'path') {
            env[key] = Path.join(projectRoot, 'node_modules', '.bin') + internals.pathSep + process.env[key];
        }
        else {
            env[key] = process.env[key];
        }
    }

    return env;
};


// Actually run the given script for the given project
internals.runCmd = function (projectRoot, env, name, script, done) {

    done = done || process.exit;
    process.stdout.write('running ' + name + ': ');

    var cmd = (process.platform === 'win32' ? 'cmd /c ' : 'sh -c ') + JSON.stringify(script);
    Exec(cmd, { cwd: projectRoot, env: env }, function (err, stdout, stderr) {
        if (err) {
            console.log('failed!');
            console.log(stdout);
            console.log(stderr);
            internals.exit(err.code, process.exit);
        } else {
            console.log('ok.');
            internals.exit(0, done);
        }
    });
}


// This method shamelessly adapted from https://github.com/cowboy/node-exit
internals.exit = function (code, callback) {
    var streams = [process.stdout, process.stderr];
    var drainCount = 0;

    function tryToExit() {
        if (drainCount === streams.length) {
            callback(code);
        }
    }

    streams.forEach(function (stream) {
        if (stream.bufferSize === 0) {
            drainCount++;
        } else {
            stream.write('', 'utf-8', function () {
                drainCount++;
                tryToExit();
            });

            stream.write = function () {};
        }
    });

    tryToExit();
}


var hook = Path.basename(process.argv[1]);
var projects = Utils.findProjects();

for (var i = 0, il = projects.length; i < il; ++i) {
    var project = projects[i];

    var env = internals.getEnv(project);
    var config = Fs.existsSync(Path.join(project, '.validate.json')) ? require(Path.join(project, '.validate.json')) : {};
    var pkg = require(Path.join(project, 'package.json'));
    var scripts = pkg[hook] || config[hook] || [];

    var tasks = [];

    for (var m = 0, ml = scripts.length; m < ml; ++m) {
        var script = scripts[m];
        var command = (pkg.scripts || {})[script] || (config.scripts || {})[script];
        var task = internals.runCmd.bind(null, project, env, script, command);
        tasks[m] = function () {

            task.call(null, tasks[i + 1]);
        };
    }

    if (tasks.length) {
        console.log('Running %s checks for %s...', hook, Path.basename(project));
        tasks[0]();
    }
}
